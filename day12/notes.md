Wouldn't be an Advent of Code without a BFS/Dijkstra problem. This one was actually fairly straightforward (once I reminded myself how to actually write Dijkstra's algorithm in C++). It was very clearly a shortest path problem, where each point was a vertext and its neighbors were the once at most one higher than itself

I created a BFS node class so I can keep track of all the things, like whether a node has been visited, its distance and its previous node it came from in one. Though later it turned out I only needed the distance, one can never be too sure what might be asked in part two. Added the start note to the queue, and started the Dijkstra loop; neightbors were added if they were accessible and hadn't been visited already. Continued the loop until the end was found. Part one done.

Part two was interesting. I had to calculate the steps from every 'a' node and find the shorted. I could run my algorithm using every node as the starting node and letting it find the end, and find the shortest. But what's the fun in that. Instead, I realised with my algorithm, what I had was the distance from the start node to every other node that was visited before we found the end. What if I turned it backwards. That is, start from the E node and reach every other node (that can be reached). A few small tweaks and I now had the distance from the **end** node to every other node that was visited. And I just had to find the minimum of them for the 'a' nodes
